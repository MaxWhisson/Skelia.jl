        - module Skelia
        - 
        - export Seq
        - export Feedback
        - export Workpool
        - export Pipeline
        - export run
        - export create_structure
        - 
        - ##############################################################################
        - ####                               Imports                                ####
        - ##############################################################################
        - 
        - using Base.Threads
        - 
        - ##############################################################################
        - ####                                Types                                 ####
        - ##############################################################################
        - 
        - abstract type Skeleton end
        - 
       15 struct QUIT
        - 
        - end 
        - 
        - struct Seq <: Skeleton
        5     f::Function
        - end
        - 
        - struct Workpool <: Skeleton
        1     n_workers::Int
        -     inner::Skeleton
        - end
        - 
        - struct Pipeline <: Skeleton
        2     stages::Vector{Skeleton}
        - end
        - 
        - struct Feedback <: Skeleton
        1     predicate::Function # true to progress
        -     inner::Skeleton
        - end
        - 
        - ##############################################################################
        - ####                              Functions                               ####
        - ##############################################################################
        - 
        5 function worker(f::Function, inputs::Channel, dest::Channel)
      197     while true
      197         item = take!(inputs)
      197         if typeof(item) == QUIT
        5             put!(inputs, QUIT())
        5             put!(dest, QUIT())
        5             break
        -         end
      384         f(item[2]) .|> (res -> put!(dest, (item[1], res)))
      192     end
        - end
        - 
        1 function create_feedback(pred::Function, inputs::Channel, destOut::Channel, destIn::Channel)
      173     while true
      173         item = take!(inputs)
      173         if typeof(item) == QUIT
        1             put!(destOut, QUIT())
        1             break
        -         end
      172         if pred(item[2])
        4             put!(destOut, item)
        -         else
      168             put!(destIn, item)
        -         end
      172     end
        - end
        - 
        4 function orderedCollector(n::Int, inputs::Channel, output::Channel)
        8     res = Vector{Any}(undef, n)
        4     for i in 1:n
       19         (pos, val) = take!(inputs)
       19         res[pos] = val
       34     end
        4     put!(output, res)
        - end
        - 
        4 function run(s::Skeleton, data::AbstractArray, collector::Function)
        4     (inputChannel, uncolChannel) = create_structure(s)
        4     return run(inputChannel, uncolChannel, data, collector)
        - end
        - 
        4 function run(inputs::Channel, outputs::Channel, data::AbstractArray, collector::Function)
        4     resultsChannel = Channel(Inf)
        8     @Threads.spawn collector(length(data), outputs, resultsChannel)
       27     zip(1:length(data), data) .|> (item -> put!(inputs, item))
        4     res = take!(resultsChannel)
        4     put!(inputs, QUIT())
        4     return res
        - end
        - 
        4 function create_structure(s::Skeleton)
        4     uncolChannel = Channel(Inf)
        4     inputChannel = buildSkel(s, uncolChannel)
        4     return (inputChannel, uncolChannel)
        - end
        - 
       10 function buildSkel(s::Seq, dest::Channel; inChan = false)
        5     inputChannel = inChan == false ? Channel(Inf) : inChan
       10     @Threads.spawn worker(s.f, inputChannel, dest)
        5     return inputChannel
        - end
        - 
        2 function buildSkel(s::Workpool, dest::Channel; inChan = false)
        1     entryChannel = inChan == false ? Channel(Inf) : inChan
        1     buildSkel(s.inner, dest, inChan = entryChannel)
        - end
        - 
        4 function buildSkel(s::Pipeline, dest::Channel; inChan = false)
        2     if length(s.stages) == 1
        1         return buildSkel(s.stages[1], dest)
        -     end
        2     inChanNext = buildSkel(Pipeline(s.stages[2:end]), dest)
        1     return buildSkel(s.stages[1], inChanNext, inChan = inChan)
        - end
        - 
        2 function buildSkel(skeleton::Feedback, dest::Channel; inChan = false)
        1     feedIn = inChan == false ? Channel(Inf) : inChan
        1     innerIn = buildSkel(skeleton.inner, feedIn)
        2     @Threads.spawn create_feedback(skeleton.predicate, feedIn, dest, innerIn)
        1     return innerIn
        - end
        - 
        - end
